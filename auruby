#!/usr/bin/env ruby

require 'yaml' 
require 'set'
require 'optparse'
require 'httparty'
require 'shellwords'
require 'fileutils'

# STRING COLORS
class String
  def colorize(code1, code2)
      "\e[#{code1}m#{self}\e[#{code2}m"
  end

  def red
    colorize(31, 0)
  end

  def green
    colorize(32, 0)
  end

  def yellow
    colorize(33, 0)
  end

  def blue
    colorize(34, 0)
  end

  def magenta
    colorize(35, 0)
  end

  def grey
    colorize(37, 0)
  end

  def bold
    colorize(1, 22)
  end
end

module AurubyConfig
  DEFAULTS = {
    'max_results' => 10,
    'number_cores' => `nproc`.to_i,
    'makepkg_options' => ''
  }.freeze

  # This reads the YAML file and merges it with defaults.
  def self.load_settings(path)
    user_config = File.file?(path) ? YAML.load_file(path) : {}

    if user_config.any?
      puts "==> ".grey + "Config loaded from #{path}".grey
    else
      puts "==> ".yellow + "Config file not found or empty, using defaults.".yellow
    end
    
    # User settings override defaults.
    DEFAULTS.merge(user_config || {})
  end
end

home = ENV['HOME']
config_file = File.join(home, '.config', 'auruby', 'config.yml')
@cache_dir = File.join(home, '.cache', 'auruby')

# Load all settings into a single, accessible constant.
SETTINGS = AurubyConfig.load_settings(config_file)

@completed_installs = Set.new
@install_stack = []

FileUtils.mkdir_p(@cache_dir)

options = {
  force: false,
  download_only: false,
  noconfirm: false
}

OptionParser.new do |opts|
  opts.banner = "Usage: auruby [options] <search-term>"

  opts.on("-f", "--force", "Force re-downloading of cached packages") { |f| options[:force] = f }
  opts.on("-d", "--download-only", "Download source files only, do not build") { |d| options[:download_only] = d }
  opts.on("-y", "--yes", "--noconfirm", "Assume 'yes' to all prompts") { |y| options[:noconfirm] = y }
  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end
end.parse!

def strip_version_constraints(dep)
  # Turns "package>=1.2.3" into "package"
  dep.split(/[<>=]/).first
end

def pkg_in_official_repos?(pkg_name)
  # Check pacman's sync database quietly for an exact package match.
  system("pacman -Ssq ^#{Shellwords.escape(pkg_name)}$ > /dev/null 2>&1")
end

def more_results(num_results)
  additional = num_results - SETTINGS['max_results']
 "There are #{additional} more results...".red.bold 
end

def prepare_cache(pkg_name, options)
  # If '--force' is used, clear the cache for this package before doing anything else.
  if options[:force]
    puts "==> ".yellow.bold + "'--force' specified, cleaning cache for '#{pkg_name}'...".bold
    clean_cache(pkg_name)
  end
end

def query(search_term)
  base_uri = 'https://aur.archlinux.org/rpc/v5'
  search_term = "#{base_uri}/search/#{search_term}"
  response = HTTParty.get(search_term, headers: {'Accept' => 'application/json'})
  abort "Error: Failed to fetch data (HTTP #{response.code})." unless response.success?
  return response.parsed_response['results']
end

def wrap_text(text, num_columns, indent)
  available_width = num_columns - indent
  words = text.split(' ')
  lines = []
  current_line = " " * indent
  words.each do |word|
    if word.length > available_width
      unless current_line.strip.empty?
        lines << current_line.rstrip
        current_line = " " * indent
      end
      remaining_word = word
      while remaining_word.length > available_width
        lines << (" " * indent) + remaining_word.slice!(0, available_width)
      end
      current_line << remaining_word + " "
    elsif current_line.length + word.length + 1 > num_columns
      lines << current_line.rstrip
      current_line = " " * indent + word + " "
    else
      current_line << word + " "
    end
  end
  lines << current_line.rstrip unless current_line.strip.empty?
  lines.join("\n")
end

def exact_match(all_packages, search_term)
  all_packages.each do |package|
    name = package["Name"]
    # If a match is found, return the name string immediately.
    return name if name.downcase == search_term.downcase
  end
  # If the loop finishes without finding a match, return nil.
  return nil
end


def no_results?(results)
  abort 'No results found' if results.empty?
end

def cache_exists?(name)
  success = false
  path = "#{@cache_dir}/#{name}"
  success = system("cd #{path} && ls .git > /dev/null") if Dir.exist?(path)
end

def clean_cache(name)
  path = File.join(@cache_dir, name)
  FileUtils.rm_rf(path) if Dir.exist?(path)
end

def clone_aur(name)
  aur_base = 'https://aur.archlinux.org/'
  system("cd #{@cache_dir} && git clone #{aur_base}/#{name}.git #{name}")
end

def parse_pkgbuild_vars(name)
  path = File.join(@cache_dir, name)
  build_file = File.join(path, 'PKGBUILD')
  abort "PKGBUILD not found for '#{name}'".bold unless File.file?(build_file)

  begin
    # This command now also sources the 'pkgname' and 'options' arrays
    command = "cd #{Shellwords.escape(path)} && source PKGBUILD >/dev/null 2>&1 && " \
              "echo \"__PKGNAMES__${pkgname[@]}\" && " \
              "echo \"__DEPS__${depends[@]}\" && " \
              "echo \"__MAKEDEPS__${makedepends[@]}\" && " \
              "echo \"__OPTIONS__${options[@]}\"" # This line was missing

    output = `bash -c #{Shellwords.escape(command)}`

    pknames = output.match(/__PKGNAMES__(.*)/)&.captures&.first&.split || []
    deps = output.match(/__DEPS__(.*)/)&.captures&.first&.split || []
    makedeps = output.match(/__MAKEDEPS__(.*)/)&.captures&.first&.split || []
    pkgbuild_opts = output.match(/__OPTIONS__(.*)/)&.captures&.first&.split || []

    return pknames, deps, makedeps, pkgbuild_opts
  rescue
    abort "Failed to parse PKGBUILD for '#{name}'".red.bold
  end
end

def makepkg(name, options, pkgbuild_opts)
  path = File.join(@cache_dir, name)

  user_opts = []
  
  if SETTINGS['makepkg_options'] && !SETTINGS['makepkg_options'].empty?
    user_opts = SETTINGS['makepkg_options'].split
  end

  final_opts = pkgbuild_opts.dup
  user_opts.each do |user_opt|
    if user_opt.start_with?('!')
      positive_opt = user_opt[1..]
      final_opts.delete(positive_opt)
    else
      negative_opt = "!" + user_opt
      final_opts.delete(negative_opt)
    end
    final_opts << user_opt
  end
  final_opts.uniq!
  
  env_parts = ["MAKEFLAGS=-j#{SETTINGS['number_cores']}"]
  
  unless final_opts.empty?
    options_string = "(#{final_opts.join(' ')})"
    env_parts << "OPTIONS=#{Shellwords.escape(options_string)}"
  end
  
  env_prefix = env_parts.join(' ')

  makepkg_cmd = "/usr/bin/makepkg -si"
  makepkg_cmd += ' --noconfirm' if options[:noconfirm]

  full_command = "#{makepkg_cmd} #{env_prefix}"
  
  Dir.chdir(path) do
    return system(full_command)
  end
end

def confirm?(options)
  negative_answers = ['n', 'no']
  ans = 'yes'
  ans = $stdin.gets.chomp.downcase unless options[:noconfirm]
  !negative_answers.include?(ans)
end

def alphabet
  [*'a'..'z']
end

def pkg_operation(options)
  value = "Install".bold
  value = "Download only".bold if options[:download_only]
  return value
end

def inform_split_pkgs(pkg_names) # Now accepts the array of names
  if pkg_names.length > 1
    puts "==> ".green.bold + "NOTE:".bold + " This is a split package.".yellow
    puts "    The following packages were installed:".yellow

    pkg_names.each do |pkg_name|
      puts "    - #{pkg_name}".bold
    end
  end
end


def install_protocol(name, options)
  # --- 1. PRE-INSTALL CHECKS ---
  # Skip if this package has already been successfully installed in this run
  if @completed_installs.include?(name)
    puts "==> ".grey.bold + "Skipping '#{name}', already handled.".bold
    return true
  end

  # Check for circular dependencies (e.g., A -> B -> A)
  if @install_stack.include?(name)
    puts "==> ".red.bold + "Error: Circular dependency detected!".bold
    puts "    Install stack: #{@install_stack.join(' -> ')} -> #{name}".red
    exit 1
  end

  @install_stack.push(name)

  puts "\n==> ".blue.bold + "Processing package: ".bold + name.yellow.bold

  # --- 2. GET PACKAGE SOURCE ---
  unless cache_exists?(name)
    puts "    Cloning AUR repository for '#{name}'...".grey
    clone_aur(name)
  end

  # --- 3. DEPENDENCY RESOLUTION ---
  puts "    Checking dependencies...".grey
  pkg_names, depends, makedepends, pkgbuild_opts = parse_pkgbuild_vars(name)
  all_deps = (depends + makedepends).uniq

  all_deps.each do |dep|
    dep_name = strip_version_constraints(dep)

    if pkg_in_official_repos?(dep_name)
      # This dependency will be handled by `makepkg -s`
      next
    elsif @completed_installs.include?(dep_name)
      # This dependency was already installed in this session
      next
    else
      puts "    Found AUR dependency: ".yellow + dep_name.bold + ". Starting recursive install...".yellow
      # RECURSIVE CALL: Install the dependency first.
      install_protocol(dep_name, options)
    end
  end

  # --- 4. BUILD THE PACKAGE ---
  if options[:download_only]
    puts "    '--download-only' specified. Skipping build for '#{name}'.".yellow
    @install_stack.pop
    return
  end

  puts "==> ".green.bold + "Dependencies for '#{name}' satisfied.".bold
  puts "    Proceed to build and install '#{name}'? (Y/n)".bold

  success = false
  if confirm?(options)
    success = makepkg(name, options, pkgbuild_opts)

    if success
       puts "==> ".green.bold + "Successfully built and installed '#{name}'.".bold
      inform_split_pkgs(pkg_names) 
      @completed_installs.add(name) # Mark as completed
    else
      puts "==> ".red.bold + "Failed to build '#{name}'. Please check the output above.".bold
      # Even on failure, we pop the stack. But we don't mark as complete.
    end
  else
    puts "    Build for '#{name}' skipped by user.".yellow
  end

  @install_stack.pop # IMPORTANT: Remove from call stack after completion or failure

  return success
end

## MAIN EXECUTION BLOCK ###

package_names = ARGV
number_cols = `tput cols`.to_i

if package_names.empty?
  puts "Usage: auruby [options] <package_name> [package_name2]...".bold
  exit 1
end

# List of packages to install after resolving user input.
final_install_list = []

package_names.each do |pkg_name|
  puts "==> ".magenta.bold + "Resolving package: #{pkg_name}".bold
  results = query(pkg_name)
  no_results?(results)

  exact_name = exact_match(results, pkg_name)

  if exact_name
    puts "    Found exact match: #{exact_name}".green
    final_install_list << exact_name

    # --- Call prepare_cache for the exact match ---
    prepare_cache(exact_name, options)

  else
    # --- Menu presentation logic from your original script ---
    puts "    No exact match found for '#{pkg_name}'. Please choose from the list:".yellow
    sorted_results = results.sort { |a, b| b['Popularity'] <=> a['Popularity'] }
    num_results = sorted_results.length

    sorted_results.each.with_index do |pkg, j|
    end

    puts more_results(num_results) if num_results >= SETTINGS['max_results']

    puts "Choose a package number for '#{pkg_name}' or type any letter to skip".bold
    ans = $stdin.gets.chomp

    if ans.match?(/^\d+$/)
      index = ans.to_i - 1
      if sorted_results[index]
        chosen_name = sorted_results[index]['Name']
        final_install_list << chosen_name

        # --- Call prepare_cache for the user's chosen package ---
        prepare_cache(chosen_name, options)

      else
        puts "Invalid selection. Skipping '#{pkg_name}'...".red
      end
    else
      puts "Skipping '#{pkg_name}'...".yellow
    end
    # --- End of menu logic ---
  end
  puts "" # Blank line for readability between packages
end

# Install all the resolved packages and their dependencies
puts "\n==> ".blue.bold + "Starting installation process for: #{final_install_list.uniq.join(', ')}".bold
# Reset the completed installs set in case --force was used on an already completed package
@completed_installs.clear if options[:force]

final_install_list.uniq.each do |pkg_to_install|
  install_protocol(pkg_to_install, options)
end

puts "\n:: ".green.bold + "auruby finished.".bold
